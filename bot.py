from cards import *
from hand_rank import hand_rank


def choose_betting(isFinal: bool, hand: list[Card]):
    """
    >>> choose_betting(False,cards.create_card_list("[♥4, ♥Q, ♠2, ♥5, ♠A]"))
    ('check',0)
    >>> choose_betting(True,cards.create_card_list("[♥4, ♥Q, ♠2, ♥5, ♠A]"))
    ('call',0)
    >>> chooose_betting(False,cards.create_card_list("[♠5, ♥5, ♠4, ♣8, ♥8]"))
    ('raise',0.25)
    >>> chooose_betting(True,cards.create_card_list("[♠5, ♥5, ♠4, ♣8, ♥8]"))
    ('call',0)
    >>> chooose_betting(True,cards.create_card_list("[♦5, ♥Q, ♠9, ♦9, ♥9]"))
    ('raise',0.25)
    """
    return ('call', 0)


def choose_discard(mode: str, hand: list[Card]):
    """
    PatternKeeper:
    1. Evaluate existing hand
    2. keep the highest formed pattern. Discard the rest.
    pro: works for pair, two pairs, three of a kind, four of a kind
    con: Unable to form strategy for flush,straight. It will see straight and flush candidates as Highcard.


    >>> choose_discard("PatternKeeper",create_card_list("[♥4, ♥Q, ♠2, ♥5, ♠A]"))
    [1, 2, 3, 4]
    >>> choose_discard("PatternKeeper",create_card_list("[♣4, ♦4, ♥10, ♦A, ♣Q]"))
    [3, 4, 5]
    >>> choose_discard("PatternKeeper",create_card_list("[♠5, ♥5, ♠4, ♣8, ♥8]"))
    [3]
    >>> choose_discard("PatternKeeper",create_card_list("[♠4, ♦5, ♠6, ♣4, ♥4]"))
    [2, 3]
    >>> choose_discard("DecisionTree",create_card_list("[♣A, ♣4, ♣8, ♣5, ♥7]"))
    [5]
    >>> choose_discard("DecisionTree",create_card_list("[♦9, ♦10, ♥6, ♥Q, ♠8]"))
    [2]
    """
    #hand_types = ["High card", "One pair", "Two pairs", "Three of a kind", "Straight", "Flush", "Full house",
    # "Four of a kind", "Straight flush"]

    match mode:
        case 'PatternKeeper':
            pattern, rank_sorted = hand_rank(hand)
            discard_list = []
            hand_only_rank = [c.rank for c in hand]
            rank_sorted_by_index = sorted(rank_sorted, key=lambda r: Card.ranks.index(r), reverse=True)
            match pattern:
                case 8:
                    pass
                case 7:  #four of a kind
                    discard_list.append(hand_only_rank.index(rank_sorted[1]) + 1)
                case 6:  #full house
                    pass
                case 5:  #flush
                    pass
                case 4:  #straight
                    pass
                case 3:  #three of a kind
                    discard_list.append(hand_only_rank.index(rank_sorted[1]) + 1)
                    discard_list.append(hand_only_rank.index(rank_sorted[2]) + 1)
                case 2:  #two pairs
                    discard_list.append(hand_only_rank.index(rank_sorted[-1]) + 1)
                case 1:  #one pair
                    for i in range(1, 4):
                        discard_list.append(hand_only_rank.index(rank_sorted[i]) + 1)
                case 0:  #high card
                    for i in range(1, 5):
                        discard_list.append(hand_only_rank.index(rank_sorted_by_index[i]) + 1)

        #generate discard
        case 'DecisionTree':
            pass
    return sorted(discard_list) if len(discard_list) != 0 else discard_list


def best_discard_strategy(hand):
    # Initialize variables to track the best strategy and its value
    max_value = 0
    best_discard = []

    # Evaluate all possible discard combinations
    for discard_set in generate_all_possible_discards(hand):
        # Simulate the outcome of drawing new cards for each discard
        for new_hand in simulate_new_hands(hand, discard_set):
            # Calculate the value of the new hand
            hand_value = evaluate_hand(new_hand)

            # Update the best discard strategy if this hand is better
            if hand_value > max_value:
                max_value = hand_value
                best_discard = discard_set

    return best_discard


def generate_all_possible_discards(hand):
    discards = [[]]

    for card in hand:
        subsets_to_add = []  # Initialises a subset list as empty, that will be added to discards

        for subset in discards:
            # For each subset currently in discards, add the current card, append these to discards
            new_subset = subset + [card]
            subsets_to_add.append(new_subset)
            #print("Card is: ", card, "adding to create: ", new_subset)
        discards.extend(subsets_to_add)
    return discards


# def get_remaining_hand(hand, discardSet):
#     remainingHand.copy(hand)
#     for card in discardSet:
#         remainingHand.remove(card)
#     return remainingHand
#
#
# Deck = Deck()
# totalDeck = Deck.cards


# simulate_new_hands takes the list of current hand cards, and the list of discard sets. It iterates through that discard set list
# and finds the possible new hands that can be generated by calling the draw_combinations function. This function is called with the
# arguments of the length of the discard set (amount of cards to draw) and the available cards in draw pile (deck - hand)


def simulate_new_hands(hand, discardSetList):
    newHandsPerDiscardSet = {}
    newDeck = Deck()
    totalDeck = newDeck.cards
    for discardSet in discardSetList:

        handForDiscard = []
        deckLen = len(totalDeck)
        discardSetLen = len(discardSet)
        handLen = len(hand)
        availableDeck = []
        availableDeckLen = deckLen - handLen

        #print('Current discardSet: ', discardSet)
        #print('This set has ', len(discardSet), 'cards removed, so', len(hand)-len(discardSet), 'are left')
        #print('There are ', availableDeckLen, 'cards to choose from to replace the discards')

        for card in totalDeck:
            if card not in hand:
                availableDeck.append(card)

        #print("Available cards in deck:", availableDeck)

        # Next block will call the draw_combinations function for each possible discard count. The possible discards are 32.
        # There will be 32 calls of the draw_combinations function that will generate each a list of hands.
        # These hands then need to be graded in terms of their value and their probability and given a weight

        draws = draw_combinations(availableDeck, discardSetLen)

        # Drawing cards. This returns a list of tuples. Tuples need to be added back to the cards not discarded
        # drawCombination is a tuple of drawn cards from the draw pile, of length discardSetLen

        remainingHand = hand.copy()

        for card in discardSet:
            remainingHand.remove(card)
        #print(remainingHand)

        for drawCombination in draws:
            handTemp = list(remainingHand) + list(drawCombination)
            #print('New hand full: ', handTemp)
            handForDiscard.append(tuple(handTemp))

        newHandsPerDiscardSet[tuple(discardSet)] = handForDiscard

    #print('Possible hands generated!')
    return newHandsPerDiscardSet


def draw_combinations(deck, r):
    n = len(deck)  # Length of deck
    indices = []  # Empty indices

    for i in range(r):
        indices.append(i)
    # Initialise a list of indices (0 to len(r) - 1)
    combinations_list = []  # List to fill with combinations

    # Iterate across the indices generated, append the deck card at that index in the deck
    combination = []
    for i in indices:
        combination.append(deck[i])
    combinations_list.append(tuple(combination))

    flag = True
    while flag:

        flag = False
        # Check whether to exit the while loop
        for i in reversed(range(r)):
            if indices[i] != i + n - r:
                #print('break!')
                flag = True
                # Flag will not be set to true if none of the indexes are not at their maximum allowed value
                break

        if flag != True:
            #print('Possible draws generated!')
            return combinations_list

        indices[i] += 1
        for j in range(i + 1, r):
            indices[j] = indices[j - 1] + 1

        combination = []
        for i in indices:
            combination.append(deck[i])
        combinations_list.append(tuple(combination))


def discard_rank_count_calculator(handSetDict, debug=False):
    # handSetDict should be the dictionary generated by the simulate_new_hands function
    discardValues = {}
    handRankCounts = {}
    discardRankCounts = {}
    for discardSet, handSet in handSetDict.items():
        discardRankCounts[discardSet] = {}
        for hand in handSet:
            handValue = hand_rank(hand)[0]
            if handValue in discardRankCounts[discardSet]:
                discardRankCounts[discardSet][handValue] += 1
            else:
                discardRankCounts[discardSet][handValue] = 1
    if debug:
        print('Discard rank counts generated!')
    return discardRankCounts


def calculate_relative_values(rankCounts,debug=False):
    rank_weights = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 8, 8: 8}
    relative_values = {}

    for discard_set, rankCountDiscard in rankCounts.items():
        total_weighted_probability = 0

        for rank, count in rankCountDiscard.items():
            probability = count / sum(rankCountDiscard.values())
            weighted_probability = probability * rank_weights.get(rank)
            total_weighted_probability += weighted_probability

        # Store the total weighted probability for this discard set
        relative_values[discard_set] = total_weighted_probability
    if debug:
        print('Weights generated!')
    return relative_values


def calculate_relative_probabilities(rankCounts,debug=False):
    for discard_set, rankCountDiscard in rankCounts.items():
        total_hands = sum(rankCountDiscard.values())
        for rank, count in rankCountDiscard.items():
            probability = count / total_hands
            rankCounts[discard_set][rank] = probability
    if debug:
        print('Probabilities generated!')
    return rankCounts


def run_best_discard(hand, debug=False):
    discards = generate_all_possible_discards(hand)
    rank_counts = discard_rank_count_calculator((simulate_new_hands(hand, discards)))
    relative_values = calculate_relative_values(rank_counts, debug=debug)
    optimalDiscard = max(relative_values, key=relative_values.get)
    probs = calculate_relative_probabilities(rank_counts, debug=debug)

    if debug:
        def remove_ansi_codes(text):
            """ Remove ANSI escape codes from a string """
            import re
            ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
            return ansi_escape.sub('', text)

        # Calculate maximum width for the 'Cards' column considering ANSI codes
        max_cards_width = max(len(remove_ansi_codes(str(cards))) for cards in rank_counts.keys()) + 2
        rank_names = {
            0: 'High Card',
            1: 'One Pair',
            2: 'Two Pairs',
            3: 'Three of a Kind',
            4: 'Straight',
            5: 'Flush',
            6: 'Full House',
            7: 'Four of a Kind',
            8: 'Straight Flush'
        }
        # Print headers with alignment
        header = f"{'Cards'.ljust(max_cards_width)}" + "  ".join(f"{name}" for name in rank_names.values())
        print(header)
        print('-' * len(header))
        # Print rows with formatted probabilities
        for cards, ranks in probs.items():
            card_str = f"{remove_ansi_codes(str(cards))}".ljust(max_cards_width)
            row = [card_str] + [f"{ranks.get(rank, 0):>10.2f}" for rank in range(9)]  # right-align probabilities
            print("  ".join(row))
    return optimalDiscard


if __name__ == '__main__':
    hand = create_card_list("[♦9, ♦10, ♥6, ♥Q, ♠8]")
    print(run_best_discard(hand, debug=True))
